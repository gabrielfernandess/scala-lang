scala> for (x <- 1 to 5) { print("-"+x) }
-1-2-3-4-5
Todo for do Scala é baseado na sintaxe “for (i <- expr)”, onde “i <- expr” é uma expressão conhecida como generator. Generators são construtores de coleções de itens, 
onde cada item da coleção será referenciado pela variável i (ou como você quiser chamar). Percebeu a expressão “1 to 5”? 
Lembra das conversões implícitas fornecidas pelo compilador Scala? No caso, o número inteiro “1” (uma instância de RichInt) tem um método chamado to,
 que recebe como argumento um número inteiro e tem como retorno uma coleção do tipo Range, um intervalo de números inteiros ordenados.

É bem comum percorrer uma coleção de números até o penúltimo elemento, o famoso “i < n”. Se este é o caso, basta utilizar o método until ao invés do to:

scala> for (x <- 1 until 5) { print("-"+x) }
-1-2-3-4
Qualquer coleção Scala é válida para uso com a cláusula for. Por exemplo, podemos inspecionar a lista de arquivos da pasta atual.


scala> val homeFiles = (new java.io.File(".")).listFiles
homeFiles: Array[java.io.File] = Array(./target)
 
scala> for (aFile <- homeFiles) { println(aFile) }
./target
Da mesma maneira como ocorre com identificadores, o compilador Scala infere o tipo da variável que referencia os elementos da coleção, mas é claro que você pode explicitar o tipo, 
se quiser.

Cláusulas for também permitem a aplicação de filtros ou guards aos generators em questão. Com isso, é possível aplicar critérios de seleção aos elementos que serão entregues 
ao bloco que será executado. Por exemplo, podemos iterar apenas sobre os números pares de uma coleção:

scala> for (i <- 1 to 10 if i % 2 == 0) { print("(%s)".format(i)) }
(2)(4)(6)(8)(10)
Podemos ser mais seletivos e especificar vários critérios diferentes, separados por ponto-e-vírgula:


scala> for (i <- 1 to 10 if i % 2 == 0; if i >= 6) {
         print("(%s)".format(i))
       }
(6)(8)(10)
E quando precisamos trabalhar com nested loops? Em Java, é comum encontrar coisas assim:


for (int i=0; i<10; i++) {
  for (int j=0; j<15; j++) {
    //Faça alguma coisa com os dois índices
  }
}
O mesmo loop em Scala, em apenas uma linha, aplicando múltiplos generators dentro da mesma cláusula for:


scala> for (i <- 1 until 10; j <- 1 until 15) {
         //Fazendo alguma coisa com i e j
       }
Nada impede, inclusive, que generators façam referências a outros generators. Também é possível aplicar filtros aos vários generators de um for. Para isso, precisamos inserir quebras 
de linha, como no exemplo abaixo:


scala> for (i <- 1 until 10 if i % 2 == 0; j <- 1 until 15 if j != i) {
         //Fazendo alguma coisa com i e j, onde j depende do valor de i
       }
Além de tudo isso, o for em Scala ainda pode produzir coleções de valores, a partir dos resultados apurados em cada iteração do loop. Este tipo de loop é chamado de for comprehension. 
Para isso, basta incluir a cláusula yield logo antes da expressão a ser executada no loop. Podemos, por exemplo, “dobrar” uma coleção de inteiros, sem muito código.


scala> for (i <- 1 to 10) yield i * 2
res5: IndexedSeq[Int] = Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
Podemos realizar qualquer operação e o resultado do bloco, em cada iteração, será apurado para construir a coleção final.


scala> for (i <- 1 to 10) yield { val x = i * 2; x + 5 }
res6: IndexedSeq[Int] = Vector(7, 9, 11, 13, 15, 17, 19, 21, 23, 25)